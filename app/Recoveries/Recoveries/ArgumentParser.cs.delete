using System;
using System.Collections.Generic;
using Recoveries.Domain;

namespace Recoveries
{
    public struct QueueKeys
    {
        public string HostName;
    }

    public enum QueueArgument
    {
        HostName = 1,
        VirtualHost = 2,
        Username = 3,
        Password = 4,
        QueueName = 5,
        OutputTo = 6,
        MaximumMessages = 7
    }

    public enum QueueCommand
    {
        Purge = 1,
        Insert = 2,
        Error = 3,
        Retry = 4,
        Print = 5,
        Dump = 6
    }

    public class ArgumentParser
    {
        public Arguments Parse(IQueueOptions queueOptions)
        {
            var arguments = new Arguments();
            var options = new Dictionary<QueueArgument, string>
            {
                {QueueArgument.HostName, queueOptions.Get<string>("HostName")},
                {QueueArgument.VirtualHost, queueOptions.Get<string>("VirtualHost")},
                {QueueArgument.Username, queueOptions.Get<string>("Username")},
                {QueueArgument.Password, queueOptions.Get<string>("Password")},
                {QueueArgument.QueueName, queueOptions.Get<string>("QueueName")},
                {QueueArgument.OutputTo, queueOptions.Get<string>("MessageFilePath")},
                {QueueArgument.MaximumMessages, Convert.ToString(queueOptions.Get<int>("MaxNumberOfMessagesToRetrieve"))}
            };

            foreach (var option in options)
            {
                arguments.Add(new Argument(option.Key,option.Value));
            }
            return arguments;
        }
    }

    public class Arguments
    {
        private readonly IList<Argument> _arguments = new List<Argument>();
        private readonly IDictionary<QueueArgument, Argument> _keys = new Dictionary<QueueArgument, Argument>();

        public void Add(Argument argument)
        {
            _arguments.Add(argument);
            if (argument.HasKey)
            {
                _keys.Add(argument.Key, argument);
            }
        }

        public TryResult At(int position, Action<Argument> argumentAction)
        {
            if (position < 0 || position >= _arguments.Count) return TryResult.Fail();
            var argument = _arguments[position];
            argumentAction(argument);
            return TryResult.Pass();
        }

        public TryResult WithKey(QueueArgument key, Action<Argument> argumentAction)
        {
            if (!_keys.ContainsKey(key)) return TryResult.Fail();
            var argument = _keys[key];
            argumentAction(argument);
            return TryResult.Pass();
        }

        public TryResult WithTypedKeyOptional<T>(QueueArgument key, Action<Argument> argumentAction) where T : IConvertible
        {
            if (!_keys.ContainsKey(key)) return TryResult.Pass();

            try
            {
                Convert.ChangeType(_keys[key].Value, typeof(T));
            }
            catch (InvalidCastException)
            {
                return TryResult.Fail();
            }

            var argument = _keys[key];
            argumentAction(argument);
            return TryResult.Pass();
        }

        public TryResult At(int position, QueueCommand command, Action argumentAction)
        {
            if (position < 0 || position >= _arguments.Count) return TryResult.Fail();
            var argument = _arguments[position];
            if (argument.Value != command) return TryResult.Fail();
            argumentAction();
            return TryResult.Pass();
        }
    }



    public class Argument
    {
        public Argument(QueueArgument key, string value)
        {
            Value = value;
            Key = key;
            HasKey = true;
        }

        public Argument(string value)
        {
            Value = value;
            HasKey = false;
        }

        public string Value { get; private set; }
        public QueueArgument Key { get; private set; }
        public bool HasKey { get; private set; }
    }

    public class TryResult
    {
        private bool _pass;

        public static TryResult Pass()
        {
            return new TryResult { _pass = true };
        }

        public static TryResult Fail()
        {
            return new TryResult { _pass = false };
        }

        public void FailWith(Action action)
        {
            if (!_pass) action();
        }
    }
}